#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package EDAMNoteStore::SyncState;
use base qw(Class::Accessor);
EDAMNoteStore::SyncState->mk_accessors( qw( currentTime fullSyncBefore updateCount uploaded ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{currentTime} = undef;
  $self->{fullSyncBefore} = undef;
  $self->{updateCount} = undef;
  $self->{uploaded} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{currentTime}) {
      $self->{currentTime} = $vals->{currentTime};
    }
    if (defined $vals->{fullSyncBefore}) {
      $self->{fullSyncBefore} = $vals->{fullSyncBefore};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
    if (defined $vals->{uploaded}) {
      $self->{uploaded} = $vals->{uploaded};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SyncState';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{currentTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{fullSyncBefore});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uploaded});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SyncState');
  if (defined $self->{currentTime}) {
    $xfer += $output->writeFieldBegin('currentTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{currentTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullSyncBefore}) {
    $xfer += $output->writeFieldBegin('fullSyncBefore', TType::I64, 2);
    $xfer += $output->writeI64($self->{fullSyncBefore});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uploaded}) {
    $xfer += $output->writeFieldBegin('uploaded', TType::I64, 4);
    $xfer += $output->writeI64($self->{uploaded});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::SyncChunk;
use base qw(Class::Accessor);
EDAMNoteStore::SyncChunk->mk_accessors( qw( currentTime chunkHighUSN updateCount notes notebooks tags searches resources expungedNotes expungedNotebooks expungedTags expungedSearches linkedNotebooks expungedLinkedNotebooks ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{currentTime} = undef;
  $self->{chunkHighUSN} = undef;
  $self->{updateCount} = undef;
  $self->{notes} = undef;
  $self->{notebooks} = undef;
  $self->{tags} = undef;
  $self->{searches} = undef;
  $self->{resources} = undef;
  $self->{expungedNotes} = undef;
  $self->{expungedNotebooks} = undef;
  $self->{expungedTags} = undef;
  $self->{expungedSearches} = undef;
  $self->{linkedNotebooks} = undef;
  $self->{expungedLinkedNotebooks} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{currentTime}) {
      $self->{currentTime} = $vals->{currentTime};
    }
    if (defined $vals->{chunkHighUSN}) {
      $self->{chunkHighUSN} = $vals->{chunkHighUSN};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
    if (defined $vals->{notes}) {
      $self->{notes} = $vals->{notes};
    }
    if (defined $vals->{notebooks}) {
      $self->{notebooks} = $vals->{notebooks};
    }
    if (defined $vals->{tags}) {
      $self->{tags} = $vals->{tags};
    }
    if (defined $vals->{searches}) {
      $self->{searches} = $vals->{searches};
    }
    if (defined $vals->{resources}) {
      $self->{resources} = $vals->{resources};
    }
    if (defined $vals->{expungedNotes}) {
      $self->{expungedNotes} = $vals->{expungedNotes};
    }
    if (defined $vals->{expungedNotebooks}) {
      $self->{expungedNotebooks} = $vals->{expungedNotebooks};
    }
    if (defined $vals->{expungedTags}) {
      $self->{expungedTags} = $vals->{expungedTags};
    }
    if (defined $vals->{expungedSearches}) {
      $self->{expungedSearches} = $vals->{expungedSearches};
    }
    if (defined $vals->{linkedNotebooks}) {
      $self->{linkedNotebooks} = $vals->{linkedNotebooks};
    }
    if (defined $vals->{expungedLinkedNotebooks}) {
      $self->{expungedLinkedNotebooks} = $vals->{expungedLinkedNotebooks};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SyncChunk';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{currentTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{chunkHighUSN});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{notes} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new EDAMTypes::Note();
            $xfer += $elem5->read($input);
            push(@{$self->{notes}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size6 = 0;
          $self->{notebooks} = [];
          my $_etype9 = 0;
          $xfer += $input->readListBegin(\$_etype9, \$_size6);
          for (my $_i10 = 0; $_i10 < $_size6; ++$_i10)
          {
            my $elem11 = undef;
            $elem11 = new EDAMTypes::Notebook();
            $xfer += $elem11->read($input);
            push(@{$self->{notebooks}},$elem11);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size12 = 0;
          $self->{tags} = [];
          my $_etype15 = 0;
          $xfer += $input->readListBegin(\$_etype15, \$_size12);
          for (my $_i16 = 0; $_i16 < $_size12; ++$_i16)
          {
            my $elem17 = undef;
            $elem17 = new EDAMTypes::Tag();
            $xfer += $elem17->read($input);
            push(@{$self->{tags}},$elem17);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size18 = 0;
          $self->{searches} = [];
          my $_etype21 = 0;
          $xfer += $input->readListBegin(\$_etype21, \$_size18);
          for (my $_i22 = 0; $_i22 < $_size18; ++$_i22)
          {
            my $elem23 = undef;
            $elem23 = new EDAMTypes::SavedSearch();
            $xfer += $elem23->read($input);
            push(@{$self->{searches}},$elem23);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size24 = 0;
          $self->{resources} = [];
          my $_etype27 = 0;
          $xfer += $input->readListBegin(\$_etype27, \$_size24);
          for (my $_i28 = 0; $_i28 < $_size24; ++$_i28)
          {
            my $elem29 = undef;
            $elem29 = new EDAMTypes::Resource();
            $xfer += $elem29->read($input);
            push(@{$self->{resources}},$elem29);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size30 = 0;
          $self->{expungedNotes} = [];
          my $_etype33 = 0;
          $xfer += $input->readListBegin(\$_etype33, \$_size30);
          for (my $_i34 = 0; $_i34 < $_size30; ++$_i34)
          {
            my $elem35 = undef;
            $xfer += $input->readString(\$elem35);
            push(@{$self->{expungedNotes}},$elem35);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size36 = 0;
          $self->{expungedNotebooks} = [];
          my $_etype39 = 0;
          $xfer += $input->readListBegin(\$_etype39, \$_size36);
          for (my $_i40 = 0; $_i40 < $_size36; ++$_i40)
          {
            my $elem41 = undef;
            $xfer += $input->readString(\$elem41);
            push(@{$self->{expungedNotebooks}},$elem41);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{expungedTags} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $xfer += $input->readString(\$elem47);
            push(@{$self->{expungedTags}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size48 = 0;
          $self->{expungedSearches} = [];
          my $_etype51 = 0;
          $xfer += $input->readListBegin(\$_etype51, \$_size48);
          for (my $_i52 = 0; $_i52 < $_size48; ++$_i52)
          {
            my $elem53 = undef;
            $xfer += $input->readString(\$elem53);
            push(@{$self->{expungedSearches}},$elem53);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size54 = 0;
          $self->{linkedNotebooks} = [];
          my $_etype57 = 0;
          $xfer += $input->readListBegin(\$_etype57, \$_size54);
          for (my $_i58 = 0; $_i58 < $_size54; ++$_i58)
          {
            my $elem59 = undef;
            $elem59 = new EDAMTypes::LinkedNotebook();
            $xfer += $elem59->read($input);
            push(@{$self->{linkedNotebooks}},$elem59);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size60 = 0;
          $self->{expungedLinkedNotebooks} = [];
          my $_etype63 = 0;
          $xfer += $input->readListBegin(\$_etype63, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $elem65 = undef;
            $xfer += $input->readString(\$elem65);
            push(@{$self->{expungedLinkedNotebooks}},$elem65);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SyncChunk');
  if (defined $self->{currentTime}) {
    $xfer += $output->writeFieldBegin('currentTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{currentTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{chunkHighUSN}) {
    $xfer += $output->writeFieldBegin('chunkHighUSN', TType::I32, 2);
    $xfer += $output->writeI32($self->{chunkHighUSN});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notes}) {
    $xfer += $output->writeFieldBegin('notes', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notes}}));
      {
        foreach my $iter66 (@{$self->{notes}}) 
        {
          $xfer += ${iter66}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebooks}) {
    $xfer += $output->writeFieldBegin('notebooks', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notebooks}}));
      {
        foreach my $iter67 (@{$self->{notebooks}}) 
        {
          $xfer += ${iter67}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tags}) {
    $xfer += $output->writeFieldBegin('tags', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{tags}}));
      {
        foreach my $iter68 (@{$self->{tags}}) 
        {
          $xfer += ${iter68}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{searches}) {
    $xfer += $output->writeFieldBegin('searches', TType::LIST, 7);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{searches}}));
      {
        foreach my $iter69 (@{$self->{searches}}) 
        {
          $xfer += ${iter69}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{resources}) {
    $xfer += $output->writeFieldBegin('resources', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{resources}}));
      {
        foreach my $iter70 (@{$self->{resources}}) 
        {
          $xfer += ${iter70}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedNotes}) {
    $xfer += $output->writeFieldBegin('expungedNotes', TType::LIST, 9);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedNotes}}));
      {
        foreach my $iter71 (@{$self->{expungedNotes}}) 
        {
          $xfer += $output->writeString($iter71);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedNotebooks}) {
    $xfer += $output->writeFieldBegin('expungedNotebooks', TType::LIST, 10);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedNotebooks}}));
      {
        foreach my $iter72 (@{$self->{expungedNotebooks}}) 
        {
          $xfer += $output->writeString($iter72);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedTags}) {
    $xfer += $output->writeFieldBegin('expungedTags', TType::LIST, 11);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedTags}}));
      {
        foreach my $iter73 (@{$self->{expungedTags}}) 
        {
          $xfer += $output->writeString($iter73);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedSearches}) {
    $xfer += $output->writeFieldBegin('expungedSearches', TType::LIST, 12);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedSearches}}));
      {
        foreach my $iter74 (@{$self->{expungedSearches}}) 
        {
          $xfer += $output->writeString($iter74);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{linkedNotebooks}) {
    $xfer += $output->writeFieldBegin('linkedNotebooks', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{linkedNotebooks}}));
      {
        foreach my $iter75 (@{$self->{linkedNotebooks}}) 
        {
          $xfer += ${iter75}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expungedLinkedNotebooks}) {
    $xfer += $output->writeFieldBegin('expungedLinkedNotebooks', TType::LIST, 14);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{expungedLinkedNotebooks}}));
      {
        foreach my $iter76 (@{$self->{expungedLinkedNotebooks}}) 
        {
          $xfer += $output->writeString($iter76);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteFilter;
use base qw(Class::Accessor);
EDAMNoteStore::NoteFilter->mk_accessors( qw( order ascending words notebookGuid tagGuids timeZone inactive ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{order} = undef;
  $self->{ascending} = undef;
  $self->{words} = undef;
  $self->{notebookGuid} = undef;
  $self->{tagGuids} = undef;
  $self->{timeZone} = undef;
  $self->{inactive} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{order}) {
      $self->{order} = $vals->{order};
    }
    if (defined $vals->{ascending}) {
      $self->{ascending} = $vals->{ascending};
    }
    if (defined $vals->{words}) {
      $self->{words} = $vals->{words};
    }
    if (defined $vals->{notebookGuid}) {
      $self->{notebookGuid} = $vals->{notebookGuid};
    }
    if (defined $vals->{tagGuids}) {
      $self->{tagGuids} = $vals->{tagGuids};
    }
    if (defined $vals->{timeZone}) {
      $self->{timeZone} = $vals->{timeZone};
    }
    if (defined $vals->{inactive}) {
      $self->{inactive} = $vals->{inactive};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteFilter';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{order});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{ascending});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{words});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{notebookGuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size77 = 0;
          $self->{tagGuids} = [];
          my $_etype80 = 0;
          $xfer += $input->readListBegin(\$_etype80, \$_size77);
          for (my $_i81 = 0; $_i81 < $_size77; ++$_i81)
          {
            my $elem82 = undef;
            $xfer += $input->readString(\$elem82);
            push(@{$self->{tagGuids}},$elem82);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{timeZone});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{inactive});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteFilter');
  if (defined $self->{order}) {
    $xfer += $output->writeFieldBegin('order', TType::I32, 1);
    $xfer += $output->writeI32($self->{order});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ascending}) {
    $xfer += $output->writeFieldBegin('ascending', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{ascending});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{words}) {
    $xfer += $output->writeFieldBegin('words', TType::STRING, 3);
    $xfer += $output->writeString($self->{words});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notebookGuid}) {
    $xfer += $output->writeFieldBegin('notebookGuid', TType::STRING, 4);
    $xfer += $output->writeString($self->{notebookGuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tagGuids}) {
    $xfer += $output->writeFieldBegin('tagGuids', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tagGuids}}));
      {
        foreach my $iter83 (@{$self->{tagGuids}}) 
        {
          $xfer += $output->writeString($iter83);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeZone}) {
    $xfer += $output->writeFieldBegin('timeZone', TType::STRING, 6);
    $xfer += $output->writeString($self->{timeZone});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inactive}) {
    $xfer += $output->writeFieldBegin('inactive', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{inactive});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteList;
use base qw(Class::Accessor);
EDAMNoteStore::NoteList->mk_accessors( qw( startIndex totalNotes notes stoppedWords searchedWords updateCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startIndex} = undef;
  $self->{totalNotes} = undef;
  $self->{notes} = undef;
  $self->{stoppedWords} = undef;
  $self->{searchedWords} = undef;
  $self->{updateCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startIndex}) {
      $self->{startIndex} = $vals->{startIndex};
    }
    if (defined $vals->{totalNotes}) {
      $self->{totalNotes} = $vals->{totalNotes};
    }
    if (defined $vals->{notes}) {
      $self->{notes} = $vals->{notes};
    }
    if (defined $vals->{stoppedWords}) {
      $self->{stoppedWords} = $vals->{stoppedWords};
    }
    if (defined $vals->{searchedWords}) {
      $self->{searchedWords} = $vals->{searchedWords};
    }
    if (defined $vals->{updateCount}) {
      $self->{updateCount} = $vals->{updateCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteList';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalNotes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size84 = 0;
          $self->{notes} = [];
          my $_etype87 = 0;
          $xfer += $input->readListBegin(\$_etype87, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $elem89 = undef;
            $elem89 = new EDAMTypes::Note();
            $xfer += $elem89->read($input);
            push(@{$self->{notes}},$elem89);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size90 = 0;
          $self->{stoppedWords} = [];
          my $_etype93 = 0;
          $xfer += $input->readListBegin(\$_etype93, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $elem95 = undef;
            $xfer += $input->readString(\$elem95);
            push(@{$self->{stoppedWords}},$elem95);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size96 = 0;
          $self->{searchedWords} = [];
          my $_etype99 = 0;
          $xfer += $input->readListBegin(\$_etype99, \$_size96);
          for (my $_i100 = 0; $_i100 < $_size96; ++$_i100)
          {
            my $elem101 = undef;
            $xfer += $input->readString(\$elem101);
            push(@{$self->{searchedWords}},$elem101);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteList');
  if (defined $self->{startIndex}) {
    $xfer += $output->writeFieldBegin('startIndex', TType::I32, 1);
    $xfer += $output->writeI32($self->{startIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalNotes}) {
    $xfer += $output->writeFieldBegin('totalNotes', TType::I32, 2);
    $xfer += $output->writeI32($self->{totalNotes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{notes}) {
    $xfer += $output->writeFieldBegin('notes', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{notes}}));
      {
        foreach my $iter102 (@{$self->{notes}}) 
        {
          $xfer += ${iter102}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stoppedWords}) {
    $xfer += $output->writeFieldBegin('stoppedWords', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{stoppedWords}}));
      {
        foreach my $iter103 (@{$self->{stoppedWords}}) 
        {
          $xfer += $output->writeString($iter103);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{searchedWords}) {
    $xfer += $output->writeFieldBegin('searchedWords', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{searchedWords}}));
      {
        foreach my $iter104 (@{$self->{searchedWords}}) 
        {
          $xfer += $output->writeString($iter104);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updateCount}) {
    $xfer += $output->writeFieldBegin('updateCount', TType::I32, 6);
    $xfer += $output->writeI32($self->{updateCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteCollectionCounts;
use base qw(Class::Accessor);
EDAMNoteStore::NoteCollectionCounts->mk_accessors( qw( notebookCounts tagCounts trashCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{notebookCounts} = undef;
  $self->{tagCounts} = undef;
  $self->{trashCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{notebookCounts}) {
      $self->{notebookCounts} = $vals->{notebookCounts};
    }
    if (defined $vals->{tagCounts}) {
      $self->{tagCounts} = $vals->{tagCounts};
    }
    if (defined $vals->{trashCount}) {
      $self->{trashCount} = $vals->{trashCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteCollectionCounts';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size105 = 0;
          $self->{notebookCounts} = {};
          my $_ktype106 = 0;
          my $_vtype107 = 0;
          $xfer += $input->readMapBegin(\$_ktype106, \$_vtype107, \$_size105);
          for (my $_i109 = 0; $_i109 < $_size105; ++$_i109)
          {
            my $key110 = '';
            my $val111 = 0;
            $xfer += $input->readString(\$key110);
            $xfer += $input->readI32(\$val111);
            $self->{notebookCounts}->{$key110} = $val111;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size112 = 0;
          $self->{tagCounts} = {};
          my $_ktype113 = 0;
          my $_vtype114 = 0;
          $xfer += $input->readMapBegin(\$_ktype113, \$_vtype114, \$_size112);
          for (my $_i116 = 0; $_i116 < $_size112; ++$_i116)
          {
            my $key117 = '';
            my $val118 = 0;
            $xfer += $input->readString(\$key117);
            $xfer += $input->readI32(\$val118);
            $self->{tagCounts}->{$key117} = $val118;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{trashCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteCollectionCounts');
  if (defined $self->{notebookCounts}) {
    $xfer += $output->writeFieldBegin('notebookCounts', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{notebookCounts}}));
      {
        while( my ($kiter119,$viter120) = each %{$self->{notebookCounts}}) 
        {
          $xfer += $output->writeString($kiter119);
          $xfer += $output->writeI32($viter120);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tagCounts}) {
    $xfer += $output->writeFieldBegin('tagCounts', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{tagCounts}}));
      {
        while( my ($kiter121,$viter122) = each %{$self->{tagCounts}}) 
        {
          $xfer += $output->writeString($kiter121);
          $xfer += $output->writeI32($viter122);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{trashCount}) {
    $xfer += $output->writeFieldBegin('trashCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{trashCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::AdImpressions;
use base qw(Class::Accessor);
EDAMNoteStore::AdImpressions->mk_accessors( qw( adId impressionCount impressionTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{adId} = undef;
  $self->{impressionCount} = undef;
  $self->{impressionTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{adId}) {
      $self->{adId} = $vals->{adId};
    }
    if (defined $vals->{impressionCount}) {
      $self->{impressionCount} = $vals->{impressionCount};
    }
    if (defined $vals->{impressionTime}) {
      $self->{impressionTime} = $vals->{impressionTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AdImpressions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{adId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{impressionCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{impressionTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AdImpressions');
  if (defined $self->{adId}) {
    $xfer += $output->writeFieldBegin('adId', TType::I32, 1);
    $xfer += $output->writeI32($self->{adId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{impressionCount}) {
    $xfer += $output->writeFieldBegin('impressionCount', TType::I32, 2);
    $xfer += $output->writeI32($self->{impressionCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{impressionTime}) {
    $xfer += $output->writeFieldBegin('impressionTime', TType::I32, 3);
    $xfer += $output->writeI32($self->{impressionTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::AdParameters;
use base qw(Class::Accessor);
EDAMNoteStore::AdParameters->mk_accessors( qw( clientLanguage impressions supportHtml clientProperties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{clientLanguage} = undef;
  $self->{impressions} = undef;
  $self->{supportHtml} = undef;
  $self->{clientProperties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{clientLanguage}) {
      $self->{clientLanguage} = $vals->{clientLanguage};
    }
    if (defined $vals->{impressions}) {
      $self->{impressions} = $vals->{impressions};
    }
    if (defined $vals->{supportHtml}) {
      $self->{supportHtml} = $vals->{supportHtml};
    }
    if (defined $vals->{clientProperties}) {
      $self->{clientProperties} = $vals->{clientProperties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AdParameters';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{clientLanguage});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size123 = 0;
          $self->{impressions} = [];
          my $_etype126 = 0;
          $xfer += $input->readListBegin(\$_etype126, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $elem128 = undef;
            $elem128 = new EDAMNoteStore::AdImpressions();
            $xfer += $elem128->read($input);
            push(@{$self->{impressions}},$elem128);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{supportHtml});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size129 = 0;
          $self->{clientProperties} = {};
          my $_ktype130 = 0;
          my $_vtype131 = 0;
          $xfer += $input->readMapBegin(\$_ktype130, \$_vtype131, \$_size129);
          for (my $_i133 = 0; $_i133 < $_size129; ++$_i133)
          {
            my $key134 = '';
            my $val135 = '';
            $xfer += $input->readString(\$key134);
            $xfer += $input->readString(\$val135);
            $self->{clientProperties}->{$key134} = $val135;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AdParameters');
  if (defined $self->{clientLanguage}) {
    $xfer += $output->writeFieldBegin('clientLanguage', TType::STRING, 2);
    $xfer += $output->writeString($self->{clientLanguage});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{impressions}) {
    $xfer += $output->writeFieldBegin('impressions', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{impressions}}));
      {
        foreach my $iter136 (@{$self->{impressions}}) 
        {
          $xfer += ${iter136}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{supportHtml}) {
    $xfer += $output->writeFieldBegin('supportHtml', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{supportHtml});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{clientProperties}) {
    $xfer += $output->writeFieldBegin('clientProperties', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{clientProperties}}));
      {
        while( my ($kiter137,$viter138) = each %{$self->{clientProperties}}) 
        {
          $xfer += $output->writeString($kiter137);
          $xfer += $output->writeString($viter138);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteEmailParameters;
use base qw(Class::Accessor);
EDAMNoteStore::NoteEmailParameters->mk_accessors( qw( guid note toAddresses ccAddresses subject message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{guid} = undef;
  $self->{note} = undef;
  $self->{toAddresses} = undef;
  $self->{ccAddresses} = undef;
  $self->{subject} = undef;
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{guid}) {
      $self->{guid} = $vals->{guid};
    }
    if (defined $vals->{note}) {
      $self->{note} = $vals->{note};
    }
    if (defined $vals->{toAddresses}) {
      $self->{toAddresses} = $vals->{toAddresses};
    }
    if (defined $vals->{ccAddresses}) {
      $self->{ccAddresses} = $vals->{ccAddresses};
    }
    if (defined $vals->{subject}) {
      $self->{subject} = $vals->{subject};
    }
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteEmailParameters';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{guid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{note} = new EDAMTypes::Note();
        $xfer += $self->{note}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size139 = 0;
          $self->{toAddresses} = [];
          my $_etype142 = 0;
          $xfer += $input->readListBegin(\$_etype142, \$_size139);
          for (my $_i143 = 0; $_i143 < $_size139; ++$_i143)
          {
            my $elem144 = undef;
            $xfer += $input->readString(\$elem144);
            push(@{$self->{toAddresses}},$elem144);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size145 = 0;
          $self->{ccAddresses} = [];
          my $_etype148 = 0;
          $xfer += $input->readListBegin(\$_etype148, \$_size145);
          for (my $_i149 = 0; $_i149 < $_size145; ++$_i149)
          {
            my $elem150 = undef;
            $xfer += $input->readString(\$elem150);
            push(@{$self->{ccAddresses}},$elem150);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subject});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteEmailParameters');
  if (defined $self->{guid}) {
    $xfer += $output->writeFieldBegin('guid', TType::STRING, 1);
    $xfer += $output->writeString($self->{guid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{note}) {
    $xfer += $output->writeFieldBegin('note', TType::STRUCT, 2);
    $xfer += $self->{note}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{toAddresses}) {
    $xfer += $output->writeFieldBegin('toAddresses', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{toAddresses}}));
      {
        foreach my $iter151 (@{$self->{toAddresses}}) 
        {
          $xfer += $output->writeString($iter151);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ccAddresses}) {
    $xfer += $output->writeFieldBegin('ccAddresses', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{ccAddresses}}));
      {
        foreach my $iter152 (@{$self->{ccAddresses}}) 
        {
          $xfer += $output->writeString($iter152);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subject}) {
    $xfer += $output->writeFieldBegin('subject', TType::STRING, 5);
    $xfer += $output->writeString($self->{subject});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 6);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package EDAMNoteStore::NoteVersionId;
use base qw(Class::Accessor);
EDAMNoteStore::NoteVersionId->mk_accessors( qw( updateSequenceNum updated saved title ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{updateSequenceNum} = undef;
  $self->{updated} = undef;
  $self->{saved} = undef;
  $self->{title} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{updateSequenceNum}) {
      $self->{updateSequenceNum} = $vals->{updateSequenceNum};
    }
    if (defined $vals->{updated}) {
      $self->{updated} = $vals->{updated};
    }
    if (defined $vals->{saved}) {
      $self->{saved} = $vals->{saved};
    }
    if (defined $vals->{title}) {
      $self->{title} = $vals->{title};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoteVersionId';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{updateSequenceNum});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{updated});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{saved});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{title});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoteVersionId');
  if (defined $self->{updateSequenceNum}) {
    $xfer += $output->writeFieldBegin('updateSequenceNum', TType::I32, 1);
    $xfer += $output->writeI32($self->{updateSequenceNum});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{updated}) {
    $xfer += $output->writeFieldBegin('updated', TType::I64, 2);
    $xfer += $output->writeI64($self->{updated});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{saved}) {
    $xfer += $output->writeFieldBegin('saved', TType::I64, 3);
    $xfer += $output->writeI64($self->{saved});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{title}) {
    $xfer += $output->writeFieldBegin('title', TType::STRING, 4);
    $xfer += $output->writeString($self->{title});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
